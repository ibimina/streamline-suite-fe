name: ğŸš€ CD - Deploy to Production
# Primary deployment target: Vercel
# Alternative deployments (Netlify, AWS) are disabled but available if needed

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: 'Skip tests and deploy directly'
        required: false
        default: false
        type: boolean

# Grant necessary permissions for GitHub token
permissions:
  contents: read # Read repository contents
  issues: write # Create/update issues
  pull-requests: write # Create/update PR comments
  deployments: write # Create deployment status
  statuses: write # Update commit status
  checks: write # Update check runs

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: ğŸ” Pre-deployment Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    outputs:
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.env.outputs.environment }}

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ·ï¸ Get version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=$(date +"%Y.%m.%d")-$(git rev-parse --short HEAD)
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Version: $VERSION"

      - name: ğŸŒ Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ $GITHUB_REF == refs/tags/* ]]; then
            ENV="production"
          else
            ENV="staging"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "ğŸŒ Environment: $ENV"

  # Build for production
  build:
    name: ğŸ—ï¸ Build for Production
    runs-on: ubuntu-latest
    needs: pre-deploy

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸ”§ Setup environment
        run: |
          echo "NEXT_PUBLIC_VERSION=${{ needs.pre-deploy.outputs.version }}" >> .env.production
          echo "NEXT_PUBLIC_BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> .env.production
          echo "NEXT_PUBLIC_COMMIT_SHA=${GITHUB_SHA}" >> .env.production

      - name: ğŸ—ï¸ Build application
        run: npm run build
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1

      - name: ğŸ—œï¸ Compress build
        run: |
          # Create compressed archive with only existing directories
          ARCHIVE_NAME="build-${{ needs.pre-deploy.outputs.version }}.tar.gz"
          FILES_TO_ARCHIVE=""

          [ -d ".next" ] && FILES_TO_ARCHIVE="$FILES_TO_ARCHIVE .next/"
          [ -d "out" ] && FILES_TO_ARCHIVE="$FILES_TO_ARCHIVE out/"
          [ -d "public" ] && FILES_TO_ARCHIVE="$FILES_TO_ARCHIVE public/"
          [ -f "package.json" ] && FILES_TO_ARCHIVE="$FILES_TO_ARCHIVE package.json"

          if [ -n "$FILES_TO_ARCHIVE" ]; then
            tar -czf "$ARCHIVE_NAME" $FILES_TO_ARCHIVE
            echo "Created archive with: $FILES_TO_ARCHIVE"
          else
            echo "No build files found, creating empty archive"
            tar -czf "$ARCHIVE_NAME" --files-from /dev/null
          fi

      - name: ğŸ“¤ Upload production build
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: build-${{ needs.pre-deploy.outputs.version }}.tar.gz
          retention-days: 30

  # Run tests (optional for workflow_dispatch)
  test-production:
    name: ğŸ§ª Production Tests
    runs-on: ubuntu-latest
    needs: [pre-deploy]
    if: github.event.inputs.skip_tests != 'true'

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸ’¾ Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: |
            ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}

      - name: ğŸ­ Install Playwright browsers
        run: npx playwright install --with-deps
        if: steps.playwright-cache.outputs.cache-hit != 'true'

      - name: ï¿½ğŸ—ï¸ Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: ğŸ§ª Run production tests
        run: npm run test:production

      - name: ğŸš€ Start production server
        run: |
          npm run start &
          sleep 15
        env:
          NODE_ENV: production

      - name: ğŸŒ Run E2E tests
        run: npm run test:e2e:production

  # Deploy to Vercel
  deploy-vercel:
    name: ğŸš€ Deploy to Vercel
    runs-on: ubuntu-latest
    needs: [pre-deploy, test-production]
    if: always() && (needs.test-production.result == 'success' || needs.test-production.result == 'skipped')
    environment: ${{ needs.pre-deploy.outputs.environment }}

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-args: ${{ needs.pre-deploy.outputs.environment == 'production' && '--prod' || '' }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./

  # Deploy to Netlify (alternative)
  deploy-netlify:
    name: ğŸŒ Deploy to Netlify
    runs-on: ubuntu-latest
    needs: [pre-deploy, build, test-production]
    if: false # Set to true to enable Netlify deployment
    environment: ${{ needs.pre-deploy.outputs.environment }}

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¤ Download build
        uses: actions/download-artifact@v4
        with:
          name: build-files

      - name: ğŸ—œï¸ Extract build
        run: tar -xzf build-${{ needs.pre-deploy.outputs.version }}.tar.gz

      - name: ğŸŒ Deploy to Netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './out'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'Deploy from GitHub Actions - ${{ needs.pre-deploy.outputs.version }}'
          enable-pull-request-comment: false
          enable-commit-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}

  # Deploy to AWS S3 + CloudFront
  deploy-aws:
    name: â˜ï¸ Deploy to AWS
    runs-on: ubuntu-latest
    needs: [pre-deploy, build, test-production]
    if: false # Set to true to enable AWS deployment
    environment: ${{ needs.pre-deploy.outputs.environment }}

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¤ Download build
        uses: actions/download-artifact@v4
        with:
          name: build-files

      - name: ğŸ—œï¸ Extract build
        run: tar -xzf build-${{ needs.pre-deploy.outputs.version }}.tar.gz

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ“¤ Sync to S3
        run: |
          aws s3 sync ./out s3://${{ secrets.AWS_S3_BUCKET }} --delete --cache-control max-age=31536000,public
          aws s3 cp ./out/index.html s3://${{ secrets.AWS_S3_BUCKET }}/index.html --cache-control max-age=0,no-cache,no-store,must-revalidate

      - name: ğŸ”„ Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"

  # Post-deployment tests
  post-deploy:
    name: ğŸ§ª Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [pre-deploy, deploy-vercel]
    if: always() && needs.deploy-vercel.result == 'success'

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸŒ Wait for deployment
        run: sleep 30

      - name: ğŸ§ª Run smoke tests
        run: npm run test:smoke
        env:
          BASE_URL: ${{ needs.pre-deploy.outputs.environment == 'production' && secrets.PRODUCTION_URL || secrets.STAGING_URL }}

      - name: â„¹ï¸ Lighthouse Testing Disabled
        run: echo "Lighthouse CI disabled due to security vulnerabilities. Use manual testing instead."

  # Create GitHub release
  create-release:
    name: ğŸ“¦ Create Release
    runs-on: ubuntu-latest
    needs: [build, test-production, pre-deploy]
    if: startsWith(github.ref, 'refs/tags/') && (needs.test-production.result == 'success' || needs.test-production.result == 'skipped')

    permissions:
      contents: write

    steps:
      - name: ğŸ“¦ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ·ï¸ Extract tag name
        id: tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Tag: $TAG_NAME"

      - name: ğŸ“ Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

          # Generate changelog
          if [ -n "$PREV_TAG" ]; then
            CHANGELOG=$(git log $PREV_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Save to file for multiline output
          echo "$CHANGELOG" > changelog.txt
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat changelog.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: ğŸ“¤ Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files

      - name: ğŸ“¦ Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.tag_name }}
          release_name: Release ${{ steps.tag.outputs.tag_name }}
          body: |
            ## ğŸš€ What's Changed

            ${{ steps.changelog.outputs.changelog }}

            ## ğŸ“Š Deployment Info
            - **Version**: ${{ steps.tag.outputs.tag_name }}
            - **Environment**: Production
            - **Commit**: ${{ github.sha }}
            - **Build Date**: ${{ github.event.head_commit.timestamp }}

            ## ğŸ”— Links
            - [ğŸŒ Live Application](${{ secrets.PRODUCTION_URL }})
            - [ğŸ“Š Monitoring Dashboard](${{ secrets.MONITORING_URL }})

            ---

            **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ steps.changelog.outputs.previous_tag }}...${{ steps.tag.outputs.tag_name }}
          draft: false
          prerelease: false

      - name: ğŸ“¤ Upload release assets
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./build-${{ needs.pre-deploy.outputs.version }}.tar.gz
          asset_name: streamline-suite-${{ needs.pre-deploy.outputs.version }}.tar.gz
          asset_content_type: application/gzip
